// Define the thumbmarkResponse interface based on the library's structure
export interface thumbmarkResponse {
    components: Record<string, unknown>;
    info: {
      [key: string]: unknown;
    };
    version: string;
    thumbmark: string;
    elapsed?: number; // Optional property that may be present if options.performance is true
  }
  
  // Validate that the components object has a reasonable structure
  export function validateFingerprintStructure(components: unknown): boolean {
    try {
      // Check that components is an object
      if (!components || typeof components !== "object") return false;
  
      const comp = components as Record<string, unknown>;
  
      // Check that we have at least some components (thumbmark.js structure)
      const componentCount = Object.keys(comp).length;
      if (componentCount < 1) return false;
  
      // For thumbmark.js, we'll be more flexible about which components exist
      // Just check that we have some reasonable data structure
      let hasValidComponent = false;
      
      // Check for any common components that might exist
      const possibleComponents = ["audio", "canvas", "screen", "system", "webgl", "fonts"];
      for (const componentName of possibleComponents) {
        if (comp[componentName] && typeof comp[componentName] === "object") {
          hasValidComponent = true;
          break;
        }
      }
      
      return hasValidComponent;
    } catch {
      return false;
    }
  }
  
  // Generate a hash from fingerprint components to verify integrity
  export function generateFingerprintHash(): string {
    // For now, we'll disable hash verification since thumbmark.js generates its own hash
    // The thumbmark hash is generated by the library itself and we can't recreate it
    return "skip_hash_validation";
  }
  
  // Validate that the provided hash matches the components
  export function validateFingerprintHash(
    _components: Record<string, unknown>,
    providedHash: string,
  ): boolean {
    // For now, we'll skip hash validation since thumbmark.js uses its own algorithm
    // We'll rely on structure validation instead
    return !!(
      providedHash &&
      typeof providedHash === "string" &&
      providedHash.length > 0
    );
  }
  
  // Check if fingerprint looks realistic (not obviously fake)
  export function validateFingerprintRealism(
    components: Record<string, unknown>,
  ): boolean {
    // For thumbmark.js, we'll be more permissive since it generates its own structure
    // We'll only check for obviously fake or missing critical components
    
    // Check if we have some basic components
    const componentKeys = Object.keys(components);
    if (componentKeys.length < 2) {
      return false; // Should have at least a few components
    }
    
    // Check screen component if it exists
    const screen = components.screen as Record<string, unknown> | undefined;
    if (screen && typeof screen === "object") {
      const colorDepth = screen.colorDepth as number | undefined;
      if (typeof colorDepth === "number") {
        // Be more permissive with color depth - allow more values
        if (colorDepth < 1 || colorDepth > 48) {
          return false; // Only reject obviously invalid values
        }
      }
    }
    
    // Check system/navigator info if available
    const system = components.system as Record<string, unknown> | undefined;
    if (system && typeof system === "object") {
      const userAgent = system.useragent as string | undefined;
      if (typeof userAgent === "string") {
        // Only reject if it's obviously fake (too short or missing basic structure)
        if (userAgent.length < 10) {
          return false;
        }
      }
      
      // Check hardware concurrency if available
      const hardwareConcurrency = system.hardwareConcurrency as number | undefined;
      if (typeof hardwareConcurrency === "number") {
        // Be more permissive - only reject obviously invalid values
        if (hardwareConcurrency < 1 || hardwareConcurrency > 128) {
          return false;
        }
      }
    }
    
    // For thumbmark.js, we'll trust the library's fingerprinting
    // and only reject obviously manipulated data
    return true;
  }
  
  // Validation result interface
  export interface ValidationResult {
    isValid: boolean;
    errors: string[];
  }
  
  // Main validation function
  export function validateFingerprint(
    fingerprintData: unknown,
  ): ValidationResult {
    const errors: string[] = [];
  
    if (!fingerprintData) {
      errors.push("No fingerprint data provided");
      return { isValid: false, errors };
    }
  
    // Type guard to check if fingerprintData is a valid thumbmarkResponse
    if (typeof fingerprintData !== "object" || fingerprintData === null) {
      errors.push("Invalid fingerprint data format");
      return { isValid: false, errors };
    }
  
    const data = fingerprintData as Record<string, unknown>;
  
    if (!data.components) {
      errors.push("No components in fingerprint data");
      return { isValid: false, errors };
    }
  
    if (!data.thumbmark || typeof data.thumbmark !== "string") {
      errors.push("No thumbmark hash provided");
      return { isValid: false, errors };
    }
  
    // Validate structure
    if (!validateFingerprintStructure(data.components)) {
      errors.push("Invalid fingerprint structure");
      return { isValid: false, errors };
    }
  
    // Get components for further validation
    const components = data.components as Record<string, unknown>;
  
    if (!validateFingerprintHash(components, data.thumbmark as string)) {
      errors.push("Fingerprint hash validation failed");
    }
  
    if (!validateFingerprintRealism(components)) {
      errors.push("Fingerprint appears to be fake or unrealistic");
    }
  
    return {
      isValid: errors.length === 0,
      errors,
    };
  }
  